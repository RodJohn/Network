Web缓存
Web缓存位于Web服务器之间（1个或多个，内容源服务器）和客户端之间（1个或多个）：
缓存会根据进来的请求保存输出内容的副本，例如html页面， 图片，文件（统称为副本），
当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。

缓存静态资源  图片 js  但是就是很危险

静态资源缓存
1.尽量读取缓存,节省流量
2.浏览器,服务器都有缓存机制
3.及时更新各个区域的缓存

缓存好处
减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快；
减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。


缓存的类型
浏览器缓存
对 于新一代的Web浏览器来说（例如：IE，Firefox）：一般都能在设置对话框中发现关于缓存的设置，通过在你的电脑上僻处一块硬盘空间用于存储你已 经看过的网站的副本。浏览器缓存根据非常简单的规则进行工作：在同一个会话过程中（在当前浏览器没有被关闭之前）会检查一次并确定缓存的副本足够新。这个 缓存对于用户点击“后退”或者点击刚访问过的链接特别有用，如果你浏览过程中访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。
使用ctrl+F5 能控制浏览器强制读取缓存
代理服务器缓存
Web代理服务器使用同样的缓存原理，只是规模更大。代理服务器群为成百上千用户服务使用同样的机制；大公司和ISP经常在他们的防火墙上架设代理缓存或者单独的缓存设备；
由 于带路服务器缓存并非客户端或者源服务器的一部分，而是位于原网络之外，请求必须路由到他们才能起作用。一个方法是手工设置你的浏览器：告诉浏览器使用 那个代理，另外一个是通过中间服务器：这个中间服务器处理所有的web请求，并将请求转发到后台网络，而用户不必配置代理，甚至不必知道代理的存在；
代理服务器缓存：是一个共享缓存，不只为一个用户服务，经常为大量用户使用，因此在减少相应时间和带宽使用方面很有效：因为同一个副本会被重用多次。
网关缓存
也被称为反向代理缓存或间接代理缓存，网关缓存也是一个中间服务器，和内网管理员部署缓存用于节省带宽不同：网关缓存一般是网站管理员自己部署：让他们的网站更容易扩展并获得更好的性能；
请求有几种方法被路由到网关缓存服务器上：其中典型的是让用一台或多台负载均衡服务器从客户端看上去是源服务器；

网络内容发布商  (Content delivery networks CDNs)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，Speedera和Akamai就是典型的网络内容发布商(下文简称CDN)。

本问主要关注于浏览器和代理缓存，当然，有些信息对于网关缓存也同样有效；

WEB缓存(cache)位于Web服务器和客户端之间。
缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。
HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。


缓存如何工作
所有的缓存都用一套规则来帮助他们决定什么时候使用缓存中的副本提供服务（假设有副本可用的情况下）；一些规则在协议中有定义（HTTP协议1.0和1.1），一些规则由缓存的管理员设置（浏览器的用户或者代理服务器的管理员）；
一般说来：遵循以下基本的规则（不必担心，你不必知道所有的细节，细节将随后说明）
如果响应头信息：告诉缓存器不要保留缓存，缓存器就不会缓存相应内容；
如果请求信息是需要认证或者安全加密的，相应内容也不会被缓存；
如果在回应中不存在校验器（ETag或者Last-Modified头信息），缓存服务器会认为缺乏直接的更新度信息，内容将会被认为不可缓存。
一个缓存的副本如果含有以下信息：内容将会被认为是足够新的
含有完整的过期时间和寿命控制头信息，并且内容仍在保鲜期内；
浏览器已经使用过缓存副本，并且在一个会话中已经检查过内容的新鲜度；
缓存代理服务器近期内已经使用过缓存副本，并且内容的最后更新时间在上次使用期之前；
够新的副本将直接从缓存中送出，而不会向源服务器发送请求；
如果缓存的副本已经太旧了，缓存服务器将向源服务器发出请求校验请求，用于确定是否可以继续使用当前拷贝继续服务；
总之：新鲜度和校验是确定内容是否可用的最重要途径：
 
如果副本足够新，从缓存中提取就立刻能用了；
而经缓存器校验后发现副本的原件没有变化，系统也会避免将副本内容从源服务器整个重新传输一遍。


HTTP控制缓存


使用Expires（过期时间）HTTP头信息来控制保鲜期
Expires（过期时间） 属性是HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修改。几乎所有的缓存服务器都支持Expires（过期时间）属性；

大部分Web服务器支持你用几种方式设置Expires属性；一般的：可以设计一个绝对时间间隔：基于客户最后查看副本的时间（最后访问时间）或者根据服务器上文档最后被修改的时间；
Expires 头信息：对于设置静态图片文件（例如导航栏和图片按钮）可缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对 用户变得相应非常快；他们对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存 服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的“刷新”按钮。
过期时间头信息属性值只能是HTTP格式的日期时间，其他的都会被解析成当前时间“之前”，副本会过期，记住：HTTP的日期时间必须是格林威治时间（GMT），而不是本地时间。举例：
Expires: Fri, 30 Oct 1998 14:19:41 GMT
所以使用过期时间属性一定要确认你的Web服务器时间设置正确，一个途径是通过网络时间同步协议（Network Time Protocol NTP），和你的系统管理员那里你可以了解更多细节。
虽然过期时间属性非常有用，但是它还是有些局限，首先：是牵扯到了日期，这样Web服务器的时间和缓存服务器的时间必须是同步的，如果有些不同步，要么是应该缓存的内容提前过期了，要么是过期结果没及时更新。
还有一个过期时间设置的问题也不容忽视：如果你设置的过期时间是一个固定的时间，如果你返回内容的时候又没有连带更新下次过期的时间，那么之后所有访问请求都会被发送给源Web服务器，反而增加了负载和响应时间；
Cache-Control（缓存控制） HTTP头信息
HTTP 1.1介绍了另外一组头信息属性：Cache-Control响应头信息，让网站的发布者可以更全面的控制他们的内容，并定位过期时间的限制。
有用的 Cache-Control响应头信息包括：
max-age=[秒] — 执行缓存被认为是最新的最长时间。类似于过期时间，这个参数是基于请求时间的相对时间间隔，而不是绝对过期时间，[秒]是一个数字，单位是秒：从请求时间开始到过期时间之间的秒数。
s-maxage=[秒] — 类似于max-age属性，除了他应用于共享（如：代理服务器）缓存
public — 标记认证内容也可以被缓存，一般来说： 经过HTTP认证才能访问的内容，输出是自动不可以缓存的；
no-cache — 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和public结合使用），或者严格要求使用最新数据的应用（不惜牺牲使用缓存的所有好处）；
no-store — 强制缓存在任何情况下都不要保留任何副本
must-revalidate — 告诉缓存必须遵循所有你给予副本的新鲜度的，HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，你高速缓存，你希望严格的遵循你的规则。
proxy-revalidate — 和 must-revalidate类似，除了他只对缓存代理服务器起作用
举例:
Cache-Control: max-age=3600, must-revalidate



实际使用
js使用版本号,显示控制
js作为脚本,在开发维护的过程中,都有修改的可能.必须及时更新缓存
1.js访问的时候添加版本号
2.nginx设置缓存带参数的url

对比分析,使用http域,不能及时更新,或者频繁更新.和我们的要求更改就刷新的要求不符


版本号的添加可以使用全局版本号或者独立版本号
设计思路 
1.url和参数确定唯一缓存
2.url为资源路径,使用文件的MD5值作为参数




请求的时候,使用引擎标签生成参数
<script src="${fileVersion('/js/product/comment3/commentlistpage.js')}" type="text/javascript"></script>
前台样式
<link href="${styleurl}/global/css/img_zoom.css?version=${.now?date}" rel="stylesheet" type="text/css" />

<#assign fileVersion= "com.tomtop.management.config.freemarker.FileVersionMethod"?new()>
public class FileVersionMethod implements TemplateMethodModel {

	@Override
	public Object exec(@SuppressWarnings("rawtypes") List arg0) throws TemplateModelException {
		if (arg0.isEmpty()) {
			throw new TemplateModelException("Wrong arguments");
		}
		String path = arg0.get(0).toString();
		
		boolean timeonly = (arg0.size() >= 2 && arg0.get(1) != null);
		
		String active = System.getProperty("spring.profiles.active");
		if("dev".equals(active)){ // 如果为开发环境则不带版本号
			return timeonly ? "" : path;
		}

		String realpath = 
FileVersionMethod.class.getClassLoader()
.getResource("").getPath() + "static" + path;
		File file = new File(realpath);
		if (file.exists()) {
			String md5 = MD5.getMd5ByFile(file);
			if(md5 != null){
				md5 = md5.substring(md5.length()-14);
			}
			return timeonly ? md5 : path + "?v=" + md5;
		}
		return timeonly ? "" : path;
	}
	
}















